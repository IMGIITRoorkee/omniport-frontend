require('@babel/polyfill')

const path = require('path')
const webpack = require('webpack')
const CleanWebpackPlugin = require('clean-webpack-plugin')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const MiniCssExtractPlugin = require('mini-css-extract-plugin')

const paths = require('./paths')

/*
  Webpack uses `publicPath` to determine where the app is being served from

  In development, we always serve from the root, which makes config easier
 */
const PUBLIC_PATH = paths.publicUrl || '/'

/*
  The base directory, an absolute path, for resolving entry points
  and loaders from configuration
 */
const context = paths.appIndexJs
const isEnvProduction = process.env.NODE_ENV === 'production'

/*
  This is the Webpack common config

  Both dev and prod configs are cascadingly derived from this
 */
module.exports = {
  // This context is required to be here for CSS Modules Babel plugin to work
  context,

  /*
    These are the 'entry points' to our application, which means
    they will be the 'root' imports that are included in JS bundle

    The first two entry points enable "hot" CSS and auto-refreshes for JS
   */
  entry: {
    core: ['@babel/polyfill', paths.appIndexJs]
  },

  // Because JavaScript can be written for both server and browser
  target: 'web',

  /*
    The stats option lets you precisely control what bundle
    information gets displayed
   */
  stats: 'minimal',

  /*
    The top-level output key contains set of options instructing Webpack on
    how it should output your bundles, assets and everything else
   */
  output: {
    path: path.resolve(__dirname, '../', 'build'),
    filename: 'bucket/js/[name]-bundle.js',
    publicPath: PUBLIC_PATH
  },

  module: {
    rules: [
      {
        // "oneOf" will traverse all following loaders until one will
        // match the requirements. When no loader matches it will fall
        // back to the "file" loader at the end of the loader list.

        oneOf: [
          // JavaScript

          {
            test: /\.(js)$/,
            loader: 'babel-loader',
            exclude: /node_modules/,
            options: {
              presets: ['@babel/preset-react', '@babel/preset-env'],
              plugins: [
                'transform-react-jsx',
                [
                  'react-css-modules',
                  {
                    context, // CSS Modules Babel plugin requires this to be here
                    generateScopedName: '[hash:base64:7]'
                    // Class hashes generated by CSS Modules are in the form [hash:base64:5]
                  }
                ],
                [
                  require.resolve('babel-plugin-named-asset-import'),
                  {
                    loaderMap: {
                      svg: {
                        ReactComponent: '@svgr/webpack?-prettier,-svgo![path]'
                      }
                    }
                  }
                ]
              ]
            }
          },

          // Stylesheets

          {
            test: /\.css$/,
            use: [
              'style-loader',
              'css-loader?importLoaders=1&modules&localIdentName=[hash:base64:7]',
              // Class hashes generated by CSS Modules are in the form [hash:base64:7]
              'postcss-loader'
            ],
          },

          // "url" loader works like "file" loader except that it embeds assets
          // smaller than specified limit in bytes as data URLs to avoid requests.

          {
            test: [/\.bmp$/, /\.gif$/, /\.jpe?g$/, /\.png$/],
            loader: require.resolve('url-loader'),
            options: {
              limit: 10000,
              name: 'bucket/media/[name].[hash:8].[ext]'
            }
          },

          // "file" loader makes sure those assets get served by WebpackDevServer.
          // When you `import` an asset, you get its (virtual) filename.
          // In production, they would get copied to the `build` folder.
          // This loader doesn't use a "test" so it will catch all modules
          // that fall through the other loaders.
          {
            loader: require.resolve('file-loader'),
            // Exclude `js` files to keep "css" loader working as it injects
            // its runtime that would otherwise be processed through "file" loader.
            // Also exclude `html` and `json` extensions so they get processed
            // by webpacks internal loaders.
            exclude: [/\.(js|mjs|jsx|ts|tsx)$/, /\.html$/, /\.json$/],
            options: {
              name: 'bucket/media/[name].[hash:8].[ext]',
              emitFile: false
            }
          }
        ]
      }
    ]
  },

  // Set alias for absolute imports in various apps
  resolve: {
    modules: [
      'node_modules',
      paths.core, // Enable absolute imports from core
      paths.formula_one, // Enable absolute imports from formula_one
      paths.services, // Enable absolute imports from services
      paths.apps // Enable absolute imports from apps
    ],
    extensions: ['.js', '.json', '.jsx', '.css'],
    alias: {
      core: paths.core,
      formula_one: paths.formula_one,
      services: paths.services,
      apps: paths.apps
    }
  },

  // Toggles performance suggestions
  performance: {
    hints: false
  },

  // The default behavior of the SplitChunksPlugin
  optimization: {
    splitChunks: {
      chunks: 'all'
    }
  },

  plugins: [
    // Enables Hot Module Replacement, otherwise known as HMR
    new webpack.HotModuleReplacementPlugin(),

    // Removes or cleans your build folders before building
    new CleanWebpackPlugin([paths.appBuild]),

    // Skips the emitting phase whenever there are errors while compiling
    new webpack.NoEmitOnErrorsPlugin(),

    // Causes the relative path of the module to be displayed when HMR is enabled
    new webpack.NamedModulesPlugin(),

    // Allows you to create global constants configurable at compile time
    new webpack.DefinePlugin({
      'process.env': JSON.stringify(process.env.NODE_ENV),
      __DEV__: true
    }),

    new MiniCssExtractPlugin({
      // Options similar to the same options in webpackOptions.output
      // both options are optional
      filename: 'static/css/[name].[contenthash:8].css',
      chunkFilename: 'static/css/[name].[contenthash:8].chunk.css'
    }),

    // Moment.js is an extremely popular library that bundles large locale files
    // by default due to how Webpack interprets its code. This is a practical
    // solution that requires the user to opt into importing specific locales.
    // It can be removed if Moment.jsis not used:
    new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/),

    // Simplifies creation of HTML files to serve your webpack bundles
    new HtmlWebpackPlugin(
      Object.assign(
        {},
        {
          inject: true,
          template: paths.appHtml
        },
        isEnvProduction
          ? {
            minify: {
              removeComments: true,
              collapseWhitespace: true,
              removeRedundantAttributes: true,
              useShortDoctype: true,
              removeEmptyAttributes: true,
              removeStyleLinkTypeAttributes: true,
              keepClosingSlash: true,
              minifyJS: true,
              minifyCSS: true,
              minifyURLs: true
            }
          }
          : undefined
      )
    )
  ]
}
